(function (factory) {
    if (typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
})(function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.msDays = exports.msHours = exports.msSeconds = exports.msMinutes = void 0;
    function isEmpty(n) {
        return n === undefined || n === null || n === 0 || isNaN(n);
    }
    exports.msMinutes = 60000;
    exports.msSeconds = 1000;
    exports.msHours = 3600000;
    exports.msDays = 24 * exports.msHours;
    /**
     * This is due to performance reason, copied from Source of TimeSpan from C# code.
     */
    const daysPerMS = 1 / exports.msDays;
    const hoursPerMS = 1 / exports.msHours;
    const minutesPerMS = 1 / exports.msMinutes;
    const secondsPerMS = 1 / exports.msSeconds;
    function padLeft(n, c = 2, t = "0") {
        let s = n.toString();
        if (s.length < c) {
            s = t + s;
        }
        return s;
    }
    class TimeSpan {
        static fromDays(n) {
            return new TimeSpan(n * exports.msDays);
        }
        static fromHours(n) {
            return new TimeSpan(n * exports.msHours);
        }
        static fromMinutes(n) {
            return new TimeSpan(n * exports.msMinutes);
        }
        static fromSeconds(n) {
            return new TimeSpan(n * exports.msSeconds);
        }
        static parse(text) {
            if (!text) {
                throw new Error("Invalid time format");
            }
            let isPM = false;
            // tslint:disable-next-line: one-variable-per-declaration
            let d, h, m, s, ms;
            const tokens = text.split(/:/);
            // split last...
            const last = tokens[tokens.length - 1];
            const lastParts = last.split(" ");
            if (lastParts.length > 1) {
                if (/pm/i.test(lastParts[1])) {
                    isPM = true;
                }
                tokens[tokens.length - 1] = lastParts[0];
            }
            const firstOfLast = lastParts[0];
            if (firstOfLast.indexOf(".") !== -1) {
                // it has ms...
                const secondParts = firstOfLast.split(".");
                if (secondParts.length > 1) {
                    tokens[tokens.length - 1] = secondParts[0];
                    ms = parseInt(secondParts[1], 10);
                }
            }
            if (tokens.length === 2) {
                // this is hour:min
                d = 0;
                h = parseInt(tokens[0], 10);
                m = parseInt(tokens[1], 10);
            }
            else if (tokens.length === 3) {
                d = 0;
                h = parseInt(tokens[0], 10);
                m = parseInt(tokens[1], 10);
                s = parseInt(tokens[2], 10);
            }
            else if (tokens.length === 4) {
                d = parseInt(tokens[0], 10);
                h = parseInt(tokens[1], 10);
                m = parseInt(tokens[2], 10);
                s = parseInt(tokens[3], 10);
            }
            return new TimeSpan(d, isPM ? h + 12 : h, m, s, ms);
        }
        get totalSeconds() {
            return this.msSinceEpoch * secondsPerMS;
        }
        get totalMinutes() {
            return this.msSinceEpoch * minutesPerMS;
        }
        get totalHours() {
            return this.msSinceEpoch * hoursPerMS;
        }
        get totalDays() {
            return this.msSinceEpoch * daysPerMS;
        }
        get totalMilliseconds() {
            return this.msSinceEpoch;
        }
        get days() {
            return Math.floor(this.msSinceEpoch / exports.msDays);
        }
        get hours() {
            return Math.floor((this.msSinceEpoch / exports.msHours) % 24);
        }
        get minutes() {
            return Math.floor((this.msSinceEpoch / exports.msMinutes) % 60);
        }
        get seconds() {
            return Math.floor((this.msSinceEpoch / exports.msSeconds) % 60);
        }
        get milliseconds() {
            return Math.floor(this.msSinceEpoch % 1000);
        }
        /**
         * Duration is always positive TimeSpan
         */
        get duration() {
            const t = this.msSinceEpoch;
            return new TimeSpan(t > 0 ? t : -t);
        }
        /**
         * Removes days and only trims given TimeSpan to TimeOfDay
         */
        get trimmedTime() {
            return new TimeSpan(Math.ceil(this.msSinceEpoch % exports.msDays));
        }
        constructor(days, hours, minutes, seconds, milliseconds) {
            if (arguments.length === 1) {
                this.msSinceEpoch = days;
            }
            else {
                this.msSinceEpoch =
                    (days || 0) * exports.msDays +
                        (hours || 0) * exports.msHours +
                        (minutes || 0) * exports.msMinutes +
                        (seconds || 0) * exports.msSeconds +
                        (milliseconds || 0);
            }
        }
        /**
         * Format the TimeSpan as time format
         * @param formatAs12 Display time as 12 hours with AM/PM (only if day is zero)
         */
        toString(formatAs12 = false) {
            let ams = this.msSinceEpoch;
            const text = [];
            let postFix = "";
            function format(max, f12 = false) {
                let txt = null;
                if (ams > max) {
                    const n = Math.floor(ams / max);
                    ams = ams % max;
                    if (f12) {
                        if (n > 12) {
                            postFix = " PM";
                            txt = padLeft(n - 12);
                        }
                        else {
                            postFix = " AM";
                        }
                    }
                    if (!txt) {
                        txt = padLeft(n);
                    }
                }
                if (txt) {
                    text.push(txt);
                }
                return txt;
            }
            const d = format(exports.msDays);
            format(exports.msHours, formatAs12 && !d);
            format(exports.msMinutes);
            let s = format(exports.msSeconds);
            if (ams) {
                s += "." + ams;
                text[text.length - 1] = s;
            }
            return `${text.join(":")}${postFix}`;
        }
        add(ts) {
            return new TimeSpan(this.msSinceEpoch + ts.msSinceEpoch);
        }
        equals(ts) {
            return ts.msSinceEpoch === this.msSinceEpoch;
        }
    }
    exports.default = TimeSpan;
    if (typeof window !== "undefined") {
        window.TimeSpan = TimeSpan;
    }
});
//# sourceMappingURL=TimeSpan.js.map